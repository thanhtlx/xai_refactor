==============================
naming-60
------------------------------
None
------------------------------
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();

     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {

       FunctionType fnType = type.toMaybeFunctionType();

-      if (fnType != null) {

+      if((fnType!=null)&&(!(type.isEmptyType()))){

         visitParameterList(t, n, fnType);

         ensureTyped(t, n, fnType.getInstanceType());

       } else {

==============================
naming-134
------------------------------
 			_annotations = new HashMap<Class<? extends Annotation>, Annotation>();

 		}

 		Annotation previous = _annotations.put(a.annotationType(), a);

-		return (previous != null) && previous.equals(a);

+		return(a!=null)&&(a.equals(a));

 	}

 }

 

------------------------------
None
==============================
naming-201
------------------------------
 	 * @param endTag tag to close

 	 */

 	private void popStackToClose(Token.EndTag e) {

-		String elName = e.name();

+		String elName=e.name().toLowerCase();

 		Element firstFound = null;

 

 		for (int pos = stack.size() - 1; pos >= 0; pos--) {

------------------------------
None
==============================
naming-256
------------------------------
None
------------------------------
                                              final int n2)

         throws ConvergenceException, MaxCountExceededException {

 

-        final int n1n2prod = n1 * n2;

+        final double n1n2prod=n1*n2;

 

         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation

         final double EU = n1n2prod / 2.0;

==============================
naming-258
------------------------------
 

 		if (v.length == 0) {

 			final BSPTree<Euclidean2D> t = getTree(false);

-			if ((Boolean) t.getAttribute()) {

+			if((t.getAttribute())!=(t.getAttribute())){

 				// the instance covers the whole space

 				setSize(Double.POSITIVE_INFINITY);

 				setBarycenter(Vector2D.NaN);

------------------------------
None
==============================
naming-268
------------------------------
None
------------------------------
      */

     public double[] fit() {

         final double[] guess = (new ParameterGuesser(getObservations())).guess();

-        return fit(new Gaussian.Parametric(), guess);

+        return fit(guess);

     }

 

     /**

==============================
naming-282
------------------------------
None
------------------------------
 public class Equality {

 

     public static boolean areEqual(Object o1, Object o2) {

-        if (o1 == null || o2 == null) {

+        if(o2==null){

             return o1 == null && o2 == null;

         } else if (isArray(o1)) {

             return isArray(o2) && areArraysEqual(o1, o2);

==============================
naming-283
------------------------------
None
------------------------------
 public class Equality {

 

     public static boolean areEqual(Object o1, Object o2) {

-        if (o1 == null || o2 == null) {

+        if(o2==null){

             return o1 == null && o2 == null;

         } else if (isArray(o1)) {

             return isArray(o2) && areArraysEqual(o1, o2);

==============================
naming-295
------------------------------
 			System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);

 			// use public constructor to ensure full validation

 			// this isn't overly efficient, but is safe

-			Partial newPartial = new Partial(iChronology, n, newValues);

+			Partial newPartial=new Partial(n,newValues);

 			iChronology.validate(newPartial, newValues);

 			return newPartial;

 		}

------------------------------
None
==============================
naming-311
------------------------------
None
------------------------------
           for (Node astParameter : astParameters.children()) {

             if (jsDocParameter != null) {

               defineSlot(astParameter, functionNode,

-                  jsDocParameter.getJSType(), true);

+                  jsDocParameter.getJSType(),false);

               jsDocParameter = jsDocParameter.getNext();

             } else {

               defineSlot(astParameter, functionNode, null, true);

==============================
naming-318
------------------------------
None
------------------------------
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();

     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {

       FunctionType fnType = type.toMaybeFunctionType();

-      if (fnType != null) {

+      if((fnType!=null)&&(!(type.isEmptyType()))){

         visitParameterList(t, n, fnType);

         ensureTyped(t, n, fnType.getInstanceType());

       } else {

==============================
naming-363
------------------------------
 	 * @param endTag tag to close

 	 */

 	private void popStackToClose(Token.EndTag et) {

-		String elName = et.name();

+		String elName=et.name().toLowerCase();

 		Element firstFound = null;

 

 		for (int pos = stack.size() - 1; pos >= 0; pos--) {

------------------------------
None
==============================
naming-428
------------------------------
None
------------------------------
     // x--4 (which is a syntax error).

     char prev = getLastChar();

     boolean negativeZero = isNegativeZero(x);

-    if (x < 0 && prev == '-') {

+    if(prev=='-'){

       add(" ");

     }

 

==============================
naming-429
------------------------------
None
------------------------------
     // x--4 (which is a syntax error).

     char prev = getLastChar();

     boolean negativeZero = isNegativeZero(x);

-    if (x < 0 && prev == '-') {

+    if(prev=='-'){

       add(" ");

     }

 

==============================
naming-437
------------------------------
None
------------------------------
       // charno == sourceExpert.length() means something is missing

       // at the end of the line

       if (excerpt.equals(LINE)

-          && 0 <= charno && charno < sourceExcerpt.length()) {

+          &&(0<=charno)){

         for (int i = 0; i < charno; i++) {

           char c = sourceExcerpt.charAt(i);

           if (Character.isWhitespace(c)) {

==============================
naming-438
------------------------------
None
------------------------------
       // charno == sourceExpert.length() means something is missing

       // at the end of the line

       if (excerpt.equals(LINE)

-          && 0 <= charno && charno < sourceExcerpt.length()) {

+          &&(0<=charno)){

         for (int i = 0; i < charno; i++) {

           char c = sourceExcerpt.charAt(i);

           if (Character.isWhitespace(c)) {

==============================
naming-440
------------------------------
None
------------------------------
           for (Node astParameter : astParameters.children()) {

             if (jsDocParameter != null) {

               defineSlot(astParameter, functionNode,

-                  jsDocParameter.getJSType(), true);

+                  jsDocParameter.getJSType(),false);

               jsDocParameter = jsDocParameter.getNext();

             } else {

               defineSlot(astParameter, functionNode, null, true);

==============================
naming-443
------------------------------
None
------------------------------
             // No charsetEncoder provided - pass straight latin characters

             // through, and escape the rest.  Doing the explicit character

             // check is measurably faster than using the CharsetEncoder.

-            if (c > 0x1f && c <= 0x7f) {

+            if((c> 31)&&(c<127)){

               sb.append(c);

             } else {

               // Other characters can be misinterpreted by some js parsers,

==============================
naming-456
------------------------------
None
------------------------------
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();

     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {

       FunctionType fnType = type.toMaybeFunctionType();

-      if (fnType != null) {

+      if((fnType!=null)&&(!(type.isEmptyType()))){

         visitParameterList(t, n, fnType);

         ensureTyped(t, n, fnType.getInstanceType());

       } else {

==============================
naming-467
------------------------------
None
------------------------------
         data.get(t.getScopeRoot()).recordNonEmptyReturn();

       }

 

-      if (t.getScopeDepth() <= 2) {

+      if((t.getScopeDepth())<2){

         // The first-order function analyzer looks at two types of variables:

         //

         // 1) Local variables that are assigned in inner scopes ("escaped vars")

==============================
naming-524
------------------------------
 			_annotations = new HashMap<Class<? extends Annotation>, Annotation>();

 		}

 		Annotation a = _annotations.put(ann.annotationType(), ann);

-		return (a != null) && a.equals(ann);

+		return(ann)!=null;

 	}

 }

 

------------------------------
None
==============================
naming-586
------------------------------
 	 * @param endTag tag to close

 	 */

 	private void popStackToClose(Token.EndTag tag) {

-		String elName = tag.name();

+		String elName=tag.name().toLowerCase();

 		Element firstFound = null;

 

 		for (int pos = stack.size() - 1; pos >= 0; pos--) {

------------------------------
None
==============================
naming-637
------------------------------
None
------------------------------
      */

     public double[] fit() {

         final double[] guess = (new ParameterGuesser(getObservations())).guess();

-        return fit(new Gaussian.Parametric(), guess);

+        return fit(guess);

     }

 

     /**

==============================
naming-694
------------------------------
None
------------------------------
     // x--4 (which is a syntax error).

     char prev = getLastChar();

     boolean negativeZero = isNegativeZero(x);

-    if (x < 0 && prev == '-') {

+    if(prev=='-'){

       add(" ");

     }

 

==============================
naming-695
------------------------------
None
------------------------------
     // x--4 (which is a syntax error).

     char prev = getLastChar();

     boolean negativeZero = isNegativeZero(x);

-    if (x < 0 && prev == '-') {

+    if(prev=='-'){

       add(" ");

     }

 

==============================
naming-702
------------------------------
None
------------------------------
           for (Node astParameter : astParameters.children()) {

             if (jsDocParameter != null) {

               defineSlot(astParameter, functionNode,

-                  jsDocParameter.getJSType(), true);

+                  jsDocParameter.getJSType(),false);

               jsDocParameter = jsDocParameter.getNext();

             } else {

               defineSlot(astParameter, functionNode, null, true);

==============================
naming-704
------------------------------
None
------------------------------
             // No charsetEncoder provided - pass straight latin characters

             // through, and escape the rest.  Doing the explicit character

             // check is measurably faster than using the CharsetEncoder.

-            if (c > 0x1f && c <= 0x7f) {

+            if((c> 31)&&(c<127)){

               sb.append(c);

             } else {

               // Other characters can be misinterpreted by some js parsers,

==============================
naming-725
------------------------------
None
------------------------------
         data.get(t.getScopeRoot()).recordNonEmptyReturn();

       }

 

-      if (t.getScopeDepth() <= 2) {

+      if((t.getScopeDepth())<2){

         // The first-order function analyzer looks at two types of variables:

         //

         // 1) Local variables that are assigned in inner scopes ("escaped vars")

==============================
naming-866
------------------------------
None
------------------------------
           for (Node astParameter : astParameters.children()) {

             if (jsDocParameter != null) {

               defineSlot(astParameter, functionNode,

-                  jsDocParameter.getJSType(), true);

+                  jsDocParameter.getJSType(),false);

               jsDocParameter = jsDocParameter.getNext();

             } else {

               defineSlot(astParameter, functionNode, null, true);

==============================
naming-867
------------------------------
None
------------------------------
             // No charsetEncoder provided - pass straight latin characters

             // through, and escape the rest.  Doing the explicit character

             // check is measurably faster than using the CharsetEncoder.

-            if (c > 0x1f && c <= 0x7f) {

+            if((c> 31)&&(c<127)){

               sb.append(c);

             } else {

               // Other characters can be misinterpreted by some js parsers,

==============================
naming-882
------------------------------
None
------------------------------
         data.get(t.getScopeRoot()).recordNonEmptyReturn();

       }

 

-      if (t.getScopeDepth() <= 2) {

+      if((t.getScopeDepth())<2){

         // The first-order function analyzer looks at two types of variables:

         //

         // 1) Local variables that are assigned in inner scopes ("escaped vars")

==============================
naming-923
------------------------------
 		if (startTag.isSelfClosing()) {

 			Element root = insertEmpty(startTag);

 			stack.add(root);

-			tokeniser.emit(new Token.EndTag(root.tagName())); // ensure we get out of whatever state we are in. emitted for yielded processing

+			tokeniser.emit(startTag);

 			return root;

 		}

 

------------------------------
None
==============================
naming-950
------------------------------
 

 		if (v.length == 0) {

 			final BSPTree<Euclidean2D> root = getTree(false);

-			if ((Boolean) root.getAttribute()) {

+			if((root.getAttribute())!=(root.getAttribute())){

 				// the instance covers the whole space

 				setSize(Double.POSITIVE_INFINITY);

 				setBarycenter(Vector2D.NaN);

------------------------------
None
==============================
expression-2
------------------------------
None
------------------------------
             endIndex = -(endIndex + 1); // this is first item AFTER end period

             endIndex = endIndex - 1;    // so this is last item BEFORE end

         }

-        if (endIndex < 0) {

+        if(endIndex<startIndex){

             emptyRange = true;

         }

         if (emptyRange) {

==============================
expression-12
------------------------------
None
------------------------------
             // No charsetEncoder provided - pass straight latin characters

             // through, and escape the rest.  Doing the explicit character

             // check is measurably faster than using the CharsetEncoder.

-            if (c > 0x1f && c <= 0x7f) {

+            if((c> 31)&&(c<127)){

               sb.append(c);

             } else {

               // Other characters can be misinterpreted by some js parsers,

==============================
expression-18
------------------------------
None
------------------------------
                     }

                     break;

             }

-            if (lineLength > 0) {

+            if(((lineLength)> 0)&&((pos)> 0)){

                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);

                 pos += lineSeparator.length;

             }

==============================
expression-20
------------------------------
 		if (rawCentralDirectoryData != null) {

 			int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0)

 					+ (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0);

-			if (expectedLength != rawCentralDirectoryData.length) {

+			if((expectedLength!=(rawCentralDirectoryData.length))&&(!hasCompressedSize)){

 				throw new ZipException("central directory zip64 extended" + " information extra field's length"

 						+ " doesn't match central directory" + " data.  Expected length " + expectedLength + " but is "

 						+ rawCentralDirectoryData.length);

------------------------------
                 + (hasCompressedSize ? DWORD : 0)

                 + (hasRelativeHeaderOffset ? DWORD : 0)

                 + (hasDiskStart ? WORD : 0);

-            if (rawCentralDirectoryData.length != expectedLength) {

+            if((rawCentralDirectoryData.length)<expectedLength){

                 throw new ZipException("central directory zip64 extended"

                                        + " information extra field's length"

                                        + " doesn't match central directory"

==============================
expression-24
------------------------------
None
------------------------------
             } else {

                 char c = value.charAt(pos);

 

-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { 

+                if(c<35){

                     // Some other chars at the start of a value caused the parser to fail, so for now

                     // encapsulate if we start in anything less than '#'. We are being conservative

                     // by including the default comment char too.

==============================
expression-29
------------------------------
 			_annotations = new HashMap<Class<? extends Annotation>, Annotation>();

 		}

 		Annotation previous = _annotations.put(ann.annotationType(), ann);

-		return (null != previous) && previous.equals(ann);

+		return(ann.equals(ann))||(previous.equals(ann));

 	}

 }

 

------------------------------
None
==============================
expression-80
------------------------------
None
------------------------------
             // No charsetEncoder provided - pass straight latin characters

             // through, and escape the rest.  Doing the explicit character

             // check is measurably faster than using the CharsetEncoder.

-            if (c > 0x1f && c <= 0x7f) {

+            if((c> 31)&&(c<127)){

               sb.append(c);

             } else {

               // Other characters can be misinterpreted by some js parsers,

==============================
expression-84
------------------------------
None
------------------------------
             } else {

                 char c = value.charAt(pos);

 

-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { 

+                if(c<35){

                     // Some other chars at the start of a value caused the parser to fail, so for now

                     // encapsulate if we start in anything less than '#'. We are being conservative

                     // by including the default comment char too.

==============================
expression-104
------------------------------
None
------------------------------
             // No charsetEncoder provided - pass straight latin characters

             // through, and escape the rest.  Doing the explicit character

             // check is measurably faster than using the CharsetEncoder.

-            if (c > 0x1f && c <= 0x7f) {

+            if((c> 31)&&(c<127)){

               sb.append(c);

             } else {

               // Other characters can be misinterpreted by some js parsers,

==============================
expression-108
------------------------------
None
------------------------------
             } else {

                 char c = value.charAt(pos);

 

-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { 

+                if(c<35){

                     // Some other chars at the start of a value caused the parser to fail, so for now

                     // encapsulate if we start in anything less than '#'. We are being conservative

                     // by including the default comment char too.

==============================
expression-128
------------------------------
None
------------------------------
             // No charsetEncoder provided - pass straight latin characters

             // through, and escape the rest.  Doing the explicit character

             // check is measurably faster than using the CharsetEncoder.

-            if (c > 0x1f && c <= 0x7f) {

+            if((c> 31)&&(c<127)){

               sb.append(c);

             } else {

               // Other characters can be misinterpreted by some js parsers,

==============================
expression-132
------------------------------
None
------------------------------
             } else {

                 char c = value.charAt(pos);

 

-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { 

+                if(c<35){

                     // Some other chars at the start of a value caused the parser to fail, so for now

                     // encapsulate if we start in anything less than '#'. We are being conservative

                     // by including the default comment char too.

==============================
statement-65
------------------------------
None
------------------------------
             } else {

                 char c = value.charAt(pos);

 

-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { 

+                if(c<35){

                     // Some other chars at the start of a value caused the parser to fail, so for now

                     // encapsulate if we start in anything less than '#'. We are being conservative

                     // by including the default comment char too.

==============================
statement-112
------------------------------
None
------------------------------
     // x--4 (which is a syntax error).

     char prev = getLastChar();

     boolean negativeZero = isNegativeZero(x);

-    if (x < 0 && prev == '-') {

+    if(prev=='-'){

       add(" ");

     }

 

